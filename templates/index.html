<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CampusDrop æœ€çµ‚å®Œç¾ç‰ˆ</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; padding: 20px; max-width: 800px; margin: 0 auto; background: #f4f4f9; color: #333; }
        .container { background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.08); position: relative; }
        h2 { text-align: center; color: #2c3e50; margin-bottom: 20px; }
        
        input[type="text"] { padding: 10px; border: 1px solid #ddd; border-radius: 6px; outline: none; transition: 0.3s; }
        input[type="text"]:focus { border-color: #007bff; box-shadow: 0 0 5px rgba(0,123,255,0.2); }
        
        button { padding: 6px 12px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; transition: 0.2s; font-size: 0.85em; }
        .btn-primary { background: #007bff; color: white; padding: 8px 15px; font-size: 0.9em; }
        .btn-success { background: #28a745; color: white; padding: 8px 15px; font-size: 0.9em;}
        .btn-danger { background: #dc3545; color: white; }
        .btn-outline { background: transparent; border: 1px solid #007bff; color: #007bff; padding: 6px 12px; }
        .btn-outline:hover { background: #e7f1ff; }
        .btn-active { background: #17a2b8; color: white; } 
        
        /* é€£ç·šä¸­ç‹€æ…‹ (ç°è‰²) */
        .btn-connecting { background: #6c757d; color: white; cursor: pointer; }
        .btn-connecting:hover { background: #5a6268; }

        .peer-item { padding: 12px; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center; }
        .peer-actions { display: flex; gap: 5px; }

        #chat_log { height: 350px; overflow-y: scroll; border: 1px solid #eee; padding: 15px; margin-top:15px; background:#fafafa; border-radius: 8px; }
        .message { margin-bottom: 10px; padding: 8px 14px; border-radius: 12px; max-width: 75%; position: relative; word-wrap: break-word; font-size: 0.95em; }
        .my-message { background: #007bff; color: white; float: right; clear: both; }
        .other-message { background: #e9ecef; color: #333; float: left; clear: both; }
        .sys-message { text-align: center; color: #999; font-size: 0.85em; clear: both; margin: 8px 0; font-style: italic; }
        
        #file_area { margin-top:15px; background:#e8f5e9; padding:20px; border-radius: 8px; border: 1px solid #c3e6cb; display:none; }
        .selected-peer { background-color: #e3f2fd; border-radius: 6px; }

        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;
        }
        .modal-content {
            background: white; padding: 25px; border-radius: 10px; width: 300px; text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); animation: popIn 0.3s;
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>

<div id="connection_modal" class="modal">
    <div class="modal-content">
        <h3 style="margin-top:0;">ğŸ”— é€£ç·šè«‹æ±‚</h3>
        <p><strong id="conn_req_sender"></strong> æƒ³è¦èˆ‡æ‚¨å»ºç«‹ P2P é€£ç·š</p>
        <div style="display:flex; justify-content: space-around; margin-top:20px;">
            <button class="btn-danger" onclick="respondToConnection(false)">æ‹’çµ•</button>
            <button class="btn-success" onclick="respondToConnection(true)">åŒæ„é€£ç·š</button>
        </div>
    </div>
</div>

<div id="file_request_modal" class="modal">
    <div class="modal-content">
        <h3 style="margin-top:0;">ğŸ“¥ æ¥æ”¶æª”æ¡ˆè«‹æ±‚</h3>
        <p><strong id="file_req_sender"></strong> æƒ³å‚³é€æª”æ¡ˆçµ¦ä½ ï¼š</p>
        <div style="background:#f8f9fa; padding:10px; border-radius:5px; margin:15px 0; word-break: break-all;">
            <span id="req_filename" style="color:#007bff; font-weight:bold;"></span><br>
            <small id="req_size" style="color:#666;"></small>
        </div>
        <div style="display:flex; justify-content: space-around;">
            <button class="btn-danger" onclick="respondToFile(false)">æ‹’çµ•</button>
            <button class="btn-success" onclick="respondToFile(true)">åŒæ„æ¥æ”¶</button>
        </div>
    </div>
</div>

<div class="container">
    <h2>ğŸ“¡ CampusDrop <small style="font-size:0.5em; color:#888;">æœ€çµ‚å®Œç¾ç‰ˆ</small></h2>

    <div style="background:#f8f9fa; padding:15px; border-radius:8px; margin-bottom:20px; display:flex; gap:10px; align-items: center;">
        <input type="text" id="my_name" placeholder="è¼¸å…¥æ‚¨çš„æš±ç¨±" style="flex-grow:1;">
        <button class="btn-primary" onclick="updateName()">æ›´æ–°æš±ç¨±</button>
    </div>
    <div style="text-align:right; font-size:0.85em; color:#666;">æˆ‘çš„ UID: <code id="display_uid" style="color:#e83e8c;">...</code></div>

    <hr style="border:0; border-top:1px solid #eee; margin: 20px 0;">

    <h3 style="font-size:1.2em;">åœ¨ç·šåŒå­¸ (<span id="count">0</span> äºº)</h3>
    <div id="peer_list" style="margin-bottom: 20px;"></div>

    <div id="file_area">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
            <h4 style="margin:0; color:#2e7d32;">ğŸ“‚ æª”æ¡ˆå‚³è¼¸</h4>
            <button class="btn-danger" onclick="disconnectCurrentPeer()">âŒ çµæŸç›®å‰é€£ç·š</button>
        </div>
        <p>ç›®å‰å°è±¡ï¼š<strong id="target_peer_name" style="color:#007bff; font-size:1.2em;">...</strong></p>
        <div style="display:flex; gap:10px; align-items: center;">
            <input type="file" id="file_input" style="flex-grow:1;">
            <button class="btn-success" onclick="askToSendFile()">è«‹æ±‚å‚³é€</button>
        </div>
        <div id="transfer_status" style="margin-top:10px; font-weight:bold; color:#555;"></div>
    </div>

    <h3 style="font-size:1.2em;">ğŸ’¬ èŠå¤©å®¤</h3>
    <div id="chat_log"></div>
    <div style="margin-top:15px; display:flex; gap:10px;">
        <input type="text" id="chat_input" placeholder="è¼¸å…¥è¨Šæ¯..." style="flex-grow:1;" onkeypress="if(event.key==='Enter') sendChat()">
        <button class="btn-primary" onclick="sendChat()">ç™¼é€</button>
    </div>
</div>

<script>
    const socket = io();
    let NAME_MAPPING = {}; 
    let currentTargetUid = null;
    let CONNECTING_PEERS = new Set();
    
    let pendingFileToSend = null;
    let pendingRequestSender = null;     
    let pendingConnectionSender = null;  

    // --- UID & Name ---
    function getUniqueUID() {
        let uid = localStorage.getItem('campus_uid');
        if (!uid) {
            uid = Math.random().toString(36).substring(2, 6).toUpperCase();
            localStorage.setItem('campus_uid', uid);
        }
        return uid;
    }
    const MY_UID = getUniqueUID();
    document.getElementById('display_uid').textContent = MY_UID;
    
    let myName = localStorage.getItem('campus_name') || 'åŒå­¸' + Math.floor(Math.random()*100);
    document.getElementById('my_name').value = myName;

    function updateName() {
        myName = document.getElementById('my_name').value;
        if(!myName.trim()) return alert("è«‹è¼¸å…¥æš±ç¨±ï¼");
        localStorage.setItem('campus_name', myName);
        socket.emit('join', { uid: MY_UID, name: myName });
        alert('âœ… æš±ç¨±å·²æ›´æ–°ï¼');
    }

    // --- Socket ---
    socket.on('connect', () => {
        console.log('Connected');
        socket.emit('join', { uid: MY_UID, name: myName });
    });

    socket.on('update_user_list', (users) => {
        const list = document.getElementById('peer_list');
        const others = users.filter(u => u.uid !== MY_UID);
        document.getElementById('count').textContent = others.length;
        
        NAME_MAPPING = {};
        users.forEach(u => NAME_MAPPING[u.uid] = u.name);
        
        if(others.length === 0) {
            list.innerHTML = '<div style="color:#999; text-align:center; padding:15px;">é™„è¿‘å°šç„¡äºº...</div>';
        } else {
            list.innerHTML = others.map(u => {
                const isFullyConnected = DATA_CHANNELS[u.uid] && DATA_CHANNELS[u.uid].readyState === 'open';
                const isConnecting = CONNECTING_PEERS.has(u.uid) || (PEER_CONNECTIONS[u.uid] && !isFullyConnected);

                let actionBtns = '';
                if (isFullyConnected) {
                    actionBtns = `
                        <button class="btn-active" onclick="selectPeer('${u.uid}')">å‚³æª”</button>
                        <button class="btn-danger" onclick="disconnectPeer('${u.uid}')">æ–·é–‹</button>
                    `;
                } else if (isConnecting) {
                    actionBtns = `<button class="btn-connecting" onclick="disconnectPeer('${u.uid}')">â³ é€£ç·šä¸­ (é»æ“Šå–æ¶ˆ)</button>`;
                } else {
                    actionBtns = `<button class="btn-outline" onclick="askToConnect('${u.uid}', '${u.name}')">è«‹æ±‚é€£ç·š</button>`;
                }

                const activeClass = (u.uid === currentTargetUid) ? 'selected-peer' : '';
                return `
                <div class="peer-item ${activeClass}">
                    <div><strong>${u.name}</strong> <span style="color:#888; font-size:0.8em;">#${u.uid}</span></div>
                    <div class="peer-actions">${actionBtns}</div>
                </div>`;
            }).join('');
        }
    });

    socket.on('group_chat', (data) => {
        const senderUID = data.sender_uid;
        const displayName = NAME_MAPPING[senderUID] || data.sender_name || senderUID;
        appendMsg(displayName, data.content, false);
    });

    function sendChat() {
        const txt = document.getElementById('chat_input').value;
        if(!txt.trim()) return;
        socket.emit('group_chat', { sender_uid: MY_UID, content: txt });
        appendMsg('æˆ‘', txt, true);
        document.getElementById('chat_input').value = '';
    }

    function appendMsg(name, txt, isMe, isSys=false) {
        const log = document.getElementById('chat_log');
        if (isSys) {
            log.innerHTML += `<div class="sys-message">${txt}</div>`;
        } else {
            const nameHtml = isMe ? '' : `<span class="msg-name" style="font-size:0.75em;color:#666;margin-bottom:2px;display:block;">${name}</span>`;
            log.innerHTML += `<div style="clear:both;"><div class="message ${isMe ? 'my-message' : 'other-message'}">${nameHtml}${txt}</div></div>`;
        }
        log.scrollTop = log.scrollHeight;
    }

    // --- WebRTC Core ---
    const PEER_CONNECTIONS = {};
    const DATA_CHANNELS = {};
    const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    function selectPeer(uid) {
        if (!DATA_CHANNELS[uid] || DATA_CHANNELS[uid].readyState !== 'open') {
             disconnectPeer(uid);
             return;
        }
        currentTargetUid = uid;
        const name = NAME_MAPPING[uid] || uid;
        document.getElementById('file_area').style.display = 'block';
        document.getElementById('target_peer_name').innerText = name;
        document.getElementById('transfer_status').innerText = "";
        socket.emit('join', { uid: MY_UID, name: myName }); 
    }

    function disconnectPeer(uid) {
        const name = NAME_MAPPING[uid] || uid;
        const isConnecting = CONNECTING_PEERS.has(uid) || (PEER_CONNECTIONS[uid] && (!DATA_CHANNELS[uid] || DATA_CHANNELS[uid].readyState !== 'open'));
        
        if(isConnecting || confirm(`ç¢ºå®šè¦èˆ‡ ${name} æ–·é–‹é€£ç·šå—ï¼Ÿ`)) {
            closeConnection(uid);
            appendMsg('ç³»çµ±', `æ‚¨å·²æ–·é–‹èˆ‡ ${name} çš„é€£ç·š`, false, true);
        }
    }

    function disconnectCurrentPeer() {
        if(currentTargetUid) disconnectPeer(currentTargetUid);
    }

    function closeConnection(uid) {
        if(PEER_CONNECTIONS[uid]) {
            PEER_CONNECTIONS[uid].close();
            delete PEER_CONNECTIONS[uid];
        }
        if(DATA_CHANNELS[uid]) {
            DATA_CHANNELS[uid].close();
            delete DATA_CHANNELS[uid];
        }
        if (currentTargetUid === uid) {
            document.getElementById('file_area').style.display = 'none';
            currentTargetUid = null;
        }
        CONNECTING_PEERS.delete(uid); 
        socket.emit('join', { uid: MY_UID, name: myName }); 
    }

    // --- é€£ç·šè«‹æ±‚é‚è¼¯ ---

    function askToConnect(targetUid, targetName) {
        appendMsg('ç³»çµ±', `æ­£åœ¨è«‹æ±‚èˆ‡ ${targetName} é€£ç·š...`, false, true);
        CONNECTING_PEERS.add(targetUid);
        socket.emit('join', { uid: MY_UID, name: myName }); 
        socket.emit('p2p_signal', { type: 'connection-request', target_uid: targetUid, sender_uid: MY_UID });
    }

    function respondToConnection(isAccepted) {
        document.getElementById('connection_modal').style.display = 'none';
        if (pendingConnectionSender) {
            socket.emit('p2p_signal', {
                type: 'connection-response',
                target_uid: pendingConnectionSender,
                sender_uid: MY_UID,
                accepted: isAccepted
            });
            if(isAccepted) {
                // B (æ¥æ”¶è€…) æŒ‰ä¸‹åŒæ„ï¼šåªè®Šç°ï¼Œä¸ç™¼ Offerï¼Œç­‰å¾… A
                CONNECTING_PEERS.add(pendingConnectionSender);
                socket.emit('join', { uid: MY_UID, name: myName }); 
                appendMsg('ç³»çµ±', `æ¥å—é€£ç·šï¼Œç­‰å¾…é€šé“å»ºç«‹...`, false, true);
            }
        }
    }

    // ğŸ”¥ çµ±ä¸€è™•ç†ä¿¡ä»¤
    socket.on('p2p_signal', async (data) => {
        const sender = data.sender_uid;
        const senderName = NAME_MAPPING[sender] || sender;
        
        // 1. æ”¶åˆ°è«‹æ±‚
        if (data.type === 'connection-request') {
            pendingConnectionSender = sender;
            document.getElementById('conn_req_sender').innerText = senderName;
            document.getElementById('connection_modal').style.display = 'flex';
            return;
        }
        // 2. æ”¶åˆ°å›æ‡‰ (A æ”¶åˆ° B çš„åŒæ„)
        else if (data.type === 'connection-response') {
            if (data.accepted) {
                appendMsg('ç³»çµ±', `${senderName} æ¥å—é€£ç·šï¼Œé–‹å§‹å»ºç«‹...`, false, true);
                // ğŸ”¥ é—œéµä¿®æ­£ï¼šåªæœ‰ A (ç™¼èµ·è€…) è² è²¬å»ºç«‹ Offer
                initiateWebRTC(sender, senderName); 
            } else {
                CONNECTING_PEERS.delete(sender); 
                appendMsg('ç³»çµ±', `âŒ ${senderName} æ‹’çµ•äº†é€£ç·š`, false, true);
                alert(`${senderName} æ‹’çµ•äº†é€£ç·š`);
                socket.emit('join', { uid: MY_UID, name: myName }); 
            }
            return;
        }

        // 3. WebRTC ä¿¡ä»¤äº¤æ›
        if(!PEER_CONNECTIONS[sender]) {
            // å¦‚æœæ˜¯ B (è¢«å‹•æ–¹)ï¼Œæ”¶åˆ° Offer æ‰å»ºç«‹ PC
            createPeerConnection(sender, senderName);
        }
        
        const pc = PEER_CONNECTIONS[sender];
        try {
            if(data.type === 'offer') {
                await pc.setRemoteDescription(data.sdp);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                socket.emit('p2p_signal', { type: 'answer', target_uid: sender, sender_uid: MY_UID, sdp: answer });
            } else if(data.type === 'answer') {
                await pc.setRemoteDescription(data.sdp);
            } else if(data.type === 'ice') {
                await pc.addIceCandidate(data.candidate);
            }
        } catch(e) { console.error(e); }
    });

    // ğŸ”¥ A å°ˆç”¨ï¼šç™¼èµ· WebRTC (Create DC & Offer)
    async function initiateWebRTC(targetUid, targetName) {
        createPeerConnection(targetUid, targetName);
        const pc = PEER_CONNECTIONS[targetUid];
        
        // åªæœ‰ç™¼èµ·è€…å»ºç«‹ DataChannel
        const dc = pc.createDataChannel("file");
        setupDataChannel(dc, targetUid, targetName);

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit('p2p_signal', { type: 'offer', target_uid: targetUid, sender_uid: MY_UID, sdp: offer });
    }

    // é€šç”¨ï¼šå»ºç«‹ PeerConnection ç‰©ä»¶
    function createPeerConnection(uid, name) {
        const pc = new RTCPeerConnection(rtcConfig);
        PEER_CONNECTIONS[uid] = pc;
        
        pc.onicecandidate = e => { if(e.candidate) socket.emit('p2p_signal', { type: 'ice', target_uid: uid, sender_uid: MY_UID, candidate: e.candidate }); };
        
        pc.oniceconnectionstatechange = () => {
             if(pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'closed') {
                closeConnection(uid);
            }
        };

        // B å°ˆç”¨ï¼šç›£è½ DataChannel (è¢«å‹•æ¥æ”¶)
        pc.ondatachannel = e => {
            setupDataChannel(e.channel, uid, name);
        };
    }

    function setupDataChannel(dc, uid, name) {
        DATA_CHANNELS[uid] = dc;
        dc.onopen = () => {
            // é€šé“é–‹é€šï¼
            CONNECTING_PEERS.delete(uid); 
            socket.emit('join', { uid: MY_UID, name: myName }); 
            appendMsg('ç³»çµ±', `âœ… èˆ‡ ${name} é€£ç·šæˆåŠŸï¼`, false, true);
            selectPeer(uid);
        };
        dc.onmessage = (e) => handleDataMessage(e, uid);
    }

    // --- æª”æ¡ˆå‚³è¼¸é‚è¼¯ ---
    function askToSendFile() {
        if (!currentTargetUid) return alert("è«‹å…ˆé¸æ“‡ä¸€ä½åŒå­¸ï¼");
        const file = document.getElementById('file_input').files[0];
        if(!file) return alert('è«‹é¸æ“‡æª”æ¡ˆ');
        
        const dc = DATA_CHANNELS[currentTargetUid];
        if(!dc || dc.readyState !== 'open') return alert('é€£ç·šå·²ä¸­æ–·');

        pendingFileToSend = file;
        dc.send(JSON.stringify({ type: 'file-request', name: file.name, size: (file.size / 1024 / 1024).toFixed(2) + ' MB' }));
        document.getElementById('transfer_status').innerText = "â³ ç­‰å¾…å°æ–¹åŒæ„ä¸­...";
        appendMsg('æˆ‘', `è«‹æ±‚å‚³é€æª”æ¡ˆ: ${file.name}`, true);
    }

    let incomingMeta = null;
    function handleDataMessage(e, senderUid) {
        const data = e.data;
        const senderName = NAME_MAPPING[senderUid] || senderUid;

        if(typeof data === 'string') {
            const msg = JSON.parse(data);
            if (msg.type === 'file-request') {
                pendingRequestSender = senderUid;
                document.getElementById('file_req_sender').innerText = senderName;
                document.getElementById('req_filename').innerText = msg.name;
                document.getElementById('req_size').innerText = msg.size;
                document.getElementById('file_request_modal').style.display = 'flex';
            } else if (msg.type === 'request-response') {
                if (msg.accepted) {
                    document.getElementById('transfer_status').innerText = "âœ… å°æ–¹å·²åŒæ„ï¼Œé–‹å§‹å‚³é€...";
                    startActualTransfer(); 
                } else {
                    document.getElementById('transfer_status').innerText = "âŒ å°æ–¹æ‹’çµ•æ¥æ”¶";
                    alert(`${senderName} æ‹’çµ•äº†æ‚¨çš„æª”æ¡ˆè«‹æ±‚`);
                    pendingFileToSend = null;
                }
            } else if (msg.type === 'meta') {
                incomingMeta = msg;
                document.getElementById('transfer_status').innerText = `æ­£åœ¨æ¥æ”¶ ${msg.name}...`;
            }
        } else {
            const blob = new Blob([data]);
            const url = URL.createObjectURL(blob);
            appendMsg(senderName, `ğŸ“¥ å‚³é€äº†æª”æ¡ˆ: <a href="${url}" download="${incomingMeta.name}" style="font-weight:bold;">${incomingMeta.name}</a>`, false);
            document.getElementById('transfer_status').innerText = `âœ… æ¥æ”¶å®Œæˆ`;
        }
    }

    function respondToFile(isAccepted) {
        document.getElementById('file_request_modal').style.display = 'none';
        const dc = DATA_CHANNELS[pendingRequestSender];
        if (dc) {
            dc.send(JSON.stringify({ type: 'request-response', accepted: isAccepted }));
            if(isAccepted) appendMsg('ç³»çµ±', `æ‚¨åŒæ„æ¥æ”¶æª”æ¡ˆ`, false, true);
        }
    }

    function startActualTransfer() {
        if (!pendingFileToSend || !currentTargetUid) return;
        const dc = DATA_CHANNELS[currentTargetUid];
        const file = pendingFileToSend;
        dc.send(JSON.stringify({ type: 'meta', name: file.name }));
        const reader = new FileReader();
        reader.onload = () => {
            dc.send(reader.result);
            document.getElementById('transfer_status').innerText = `âœ… å‚³é€å®Œæˆ`;
            pendingFileToSend = null; 
        };
        reader.readAsArrayBuffer(file);
    }
</script>

</body>
</html>