<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="utf-8">
    <title>CampusDrop P2P åˆ†äº«</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        body { font-family: Arial; padding: 20px; }
        .peer-list { margin-top: 15px; border: 1px solid #ccc; padding: 10px; }
        .peer-item { padding: 8px; border-bottom: 1px dashed #eee; cursor: pointer; }
        .peer-item:hover { background-color: #f0f0f0; }
        .status { font-weight: bold; color: green; }
    </style>
</head>
<body>
    <h1>CampusDrop ç¶²è·¯é€šè¨Šå°ˆé¡Œ</h1>
    
    <input type="text" id="n" placeholder="è¼¸å…¥æš±ç¨±" value="{{ my_name }}">
    <button onclick="setName()">è¨­å®šæš±ç¨±ä¸¦ä¸Šç·š</button>
    <p>æˆ‘çš„ UID: <span id="my_uid" class="status">æ­£åœ¨é€£æ¥...</span></p>
    <hr>

    <h2>åœ¨ç·šåŒå­¸ (<span id="count">0</span> äºº)</h2>
    <p>æ¯ 3 ç§’è‡ªå‹•æ›´æ–° mDNS åˆ—è¡¨ï¼Œç”¨æ–¼**åˆ¤æ–·æ˜¯å¦åœ¨æ ¡å…§**ã€‚</p>
    <div id="peer_list" class="peer-list"></div>
    <hr>
    
    <h2>ç¾¤çµ„èŠå¤©å®¤ (WebSocket å»£æ’­)</h2>
    <input type="text" id="chat_input" placeholder="è¼¸å…¥è¨Šæ¯...">
    <button onclick="sendChat()">ç™¼é€</button>
    <div id="chat_log" style="height: 200px; overflow-y: scroll; border: 1px solid #ddd; margin-top: 10px; padding: 10px;"></div>


    <script>
        // --- 1. å…¨å±€è¨­å®š ---
        // æ³¨æ„ï¼šé€™è£¡çš„ MY_UID å’Œ my_name å·²ç¶“ç”± Python å¾Œç«¯å‚³å…¥
        const MY_UID = '{{ my_uuid }}'; 
        document.getElementById('my_uid').textContent = MY_UID;
        
        // é€£æ¥åˆ°å¾Œç«¯ Socket.IO æœå‹™
        const socket = io(); 
        const PEER_CONNECTIONS = {}; // å„²å­˜æ‰€æœ‰ WebRTC é€£ç·š
        
        // --- 2. WebSocket/SocketIO äº‹ä»¶è™•ç† ---
        socket.on('connect', () => {
            console.log('ğŸ”— SocketIO é€£ç·šæˆåŠŸï¼é–‹å§‹ç™¼é€ä¿¡ä»¤ UID.');
            // é€£ç·šå¾Œç«‹å³ç™¼é€è‡ªå·±çš„ UID çµ¦ä¼ºæœå™¨
            socket.emit('set_uid', { uid: MY_UID });
        });

        socket.on('p2p_signal', (data) => {
            // æ”¶åˆ° P2P ä¿¡ä»¤ï¼ˆSDP æˆ– ICE Candidateï¼‰ï¼ŒåŸ·è¡Œ WebRTC é‚è¼¯
            handleP2PSignaling(data);
        });

        socket.on('group_chat', (data) => {
            // æ”¶åˆ°ç¾¤çµ„èŠå¤©è¨Šæ¯ (é€™ä¾†è‡ªé ç«¯ç¯€é»)
            // ä½¿ç”¨ data.sender_uid ä¾†æ¨™è­˜ç™¼é€è€…
            displayChat(data.sender_uid, data.content, new Date(data.timestamp * 1000).toLocaleTimeString());
        });

        // --- 3. UI/API äº¤äº’å‡½æ•¸ ---

        function setName() {
            const name = document.getElementById('n').value;
            fetch('/setname', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name: name })
            })
            .then(r => r.json())
            .then(data => {
                alert(`å·²ä¸Šç·šç‚º: ${data.name}`);
                fetchPeers(); 
            });
        }

        function fetchPeers() {
            // è«‹æ±‚ mDNS ç™¼ç¾çš„é„°è¿‘ç¯€é»åˆ—è¡¨
            fetch('/peers')
            .then(r => r.json())
            .then(peers => {
                document.getElementById('count').textContent = peers.length;
                
                const html = peers.map(p => `
                    <div class="peer-item" onclick="startP2P('${p.uid}', '${p.ip}')">
                        <strong>${p.name}</strong> (${p.ip}) 
                        <span class="status">[${PEER_CONNECTIONS[p.uid] ? 'P2P é€£ç·šä¸­' : 'æœªé€£ç·š'}]</span>
                        <br><small>UID: ${p.uid}</small>
                    </div>
                `).join('');
                document.getElementById('peer_list').innerHTML = html;
            });
        }

        // å®šæ™‚åˆ·æ–° mDNS åˆ—è¡¨ (æ¯ 3 ç§’)
        setInterval(fetchPeers, 3000);

        function sendChat() {
            const input = document.getElementById('chat_input');
            const content = input.value;
            if (content.trim()) {
                // 1. ç™¼é€çµ¦ SocketIO ä¼ºæœå™¨é€²è¡Œå»£æ’­
                socket.emit('group_chat', { content: content });
                
                // 2. æœ¬åœ°ç«‹å³é¡¯ç¤ºè‡ªå·±çš„è¨Šæ¯ (ä½¿ç”¨ MY_UID æ¨™è­˜è‡ªå·±)
                displayChat(MY_UID, content, new Date().toLocaleTimeString()); 
                
                input.value = '';
            }
        }

        function displayChat(uid, content, timestamp) {
            const log = document.getElementById('chat_log');
            // åˆ¤æ–·ç™¼é€è€…æ˜¯å¦ç‚ºè‡ªå·± (MY_UID)
            const sender = (uid === MY_UID) ? 'æˆ‘' : uid; 

            log.innerHTML += `
                <p>
                    <small>[${timestamp}]</small> 
                    <strong>${sender}:</strong> ${content}
                </p>`;
            log.scrollTop = log.scrollHeight; // æ»¾å‹•åˆ°åº•éƒ¨
        }
        
        // --- 4. WebRTC P2P æ ¸å¿ƒé‚è¼¯ (å¾…å®Œæˆ) ---
        
        function startP2P(targetUid, targetIp) {
            if (PEER_CONNECTIONS[targetUid]) {
                console.log('å·²é€£ç·šæˆ–æ­£åœ¨é€£ç·š...');
                return;
            }
            
            console.log(`ğŸš€ å˜—è©¦èˆ‡ ${targetUid} å»ºç«‹ P2P é€£ç·š...`);
            
            // 1. å‰µå»º RTCPeerConnection å¯¦ä¾‹
            const pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] 
            });
            
            PEER_CONNECTIONS[targetUid] = pc;
            
            // 2. è™•ç† ICE å€™é¸è€… (é€šé SocketIO ç™¼é€çµ¦ç›®æ¨™)
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('p2p_signal', {
                        type: 'ice-candidate',
                        target_uid: targetUid,
                        signal: event.candidate
                    });
                }
            };
            
            // 3. å‰µå»º DataChannel (ç”¨æ–¼å‚³è¼¸æª”æ¡ˆ/æ•¸æ“š)
            const dataChannel = pc.createDataChannel("file-transfer");
            dataChannel.onopen = () => {
                console.log(`âœ… P2P DataChannel é€£ç·šåˆ° ${targetUid} æˆåŠŸ!`);
                fetchPeers(); // åˆ·æ–°åˆ—è¡¨é¡¯ç¤ºé€£ç·šç‹€æ…‹
            };
            
            // 4. å‰µå»º Offer
            pc.createOffer()
                .then(offer => pc.setLocalDescription(offer))
                .then(() => {
                    // ç™¼é€ Offer çµ¦ä¿¡ä»¤ä¼ºæœå™¨
                    socket.emit('p2p_signal', {
                        type: 'offer',
                        target_uid: targetUid,
                        signal: pc.localDescription
                    });
                });
        }
        
        function handleP2PSignaling(data) {
            const senderUid = data.sender_uid;
            const signal = data.signal;
            let pc = PEER_CONNECTIONS[senderUid];

            // åˆ¤æ–·æ˜¯å¦ç‚ºç¬¬ä¸€æ¬¡æ”¶åˆ°ä¿¡ä»¤ (ä¾‹å¦‚æ”¶åˆ° Offer)
            if (!pc) {
                pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                PEER_CONNECTIONS[senderUid] = pc;
                
                // è™•ç†é ç«¯å‰µå»ºçš„ DataChannel
                pc.ondatachannel = (event) => {
                    const dataChannel = event.channel;
                    dataChannel.onopen = () => {
                        console.log(`âœ… P2P DataChannel å¾ ${senderUid} é€£ç·šæˆåŠŸ!`);
                        fetchPeers();
                    };
                    // åœ¨é€™è£¡å¯¦ä½œæ¥æ”¶æª”æ¡ˆçš„é‚è¼¯
                };
                
                // è™•ç† ICE å€™é¸è€…ï¼ˆèˆ‡ startP2P ä¸­è¨­ç½®çš„ç›¸åŒï¼‰
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        socket.emit('p2p_signal', {
                            type: 'ice-candidate',
                            target_uid: senderUid,
                            signal: event.candidate
                        });
                    }
                };
            }

            // è¨­ç½®é ç«¯æè¿° (Offer/Answer)
            if (signal.type === 'offer') {
                pc.setRemoteDescription(new RTCSessionDescription(signal))
                    .then(() => pc.createAnswer())
                    .then(answer => pc.setLocalDescription(answer))
                    .then(() => {
                        // å›å‚³ Answer
                        socket.emit('p2p_signal', {
                            type: 'answer',
                            target_uid: senderUid,
                            signal: pc.localDescription
                        });
                    });
            } else if (signal.type === 'answer') {
                pc.setRemoteDescription(new RTCSessionDescription(signal));
            } else if (signal.type === 'ice-candidate') {
                pc.addIceCandidate(new RTCIceCandidate(signal));
            }
        }

    </script>
</body>
</html>